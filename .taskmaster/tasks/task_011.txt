# Task ID: 11
# Title: Implement Error Handling and Logging System
# Status: pending
# Dependencies: 1, 9
# Priority: medium
# Description: Develop a comprehensive error handling and logging system to track issues, provide user feedback, and facilitate troubleshooting.
# Details:
Create an ErrorHandler class that:

1. Implements centralized error handling
   - Categorize errors (network, API, system, user)
   - Provide user-friendly error messages
   - Log detailed error information for debugging

2. Develops a robust logging system
   - Use Python's logging module with rotating file handlers
   - Log different levels (DEBUG, INFO, WARNING, ERROR)
   - Include contextual information in log entries

3. Implements error recovery strategies
   - Automatic retry for transient errors
   - Fallback options for service failures
   - Graceful degradation of functionality

Implementation approach:
```python
class ErrorHandler:
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.setup_logging()
        
    def setup_logging(self):
        # Create logs directory in user's AppData
        log_dir = os.path.join(
            os.environ.get('APPDATA'),
            'VoiceDictationAssistant',
            'logs'
        )
        os.makedirs(log_dir, exist_ok=True)
        
        # Configure logging
        log_file = os.path.join(log_dir, 'app.log')
        
        # Create rotating file handler (10 files, 1MB each)
        file_handler = RotatingFileHandler(
            log_file, 
            maxBytes=1024*1024, 
            backupCount=10
        )
        
        # Define log format
        log_format = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(log_format)
        
        # Configure root logger
        root_logger = logging.getLogger()
        root_logger.setLevel(logging.INFO)
        root_logger.addHandler(file_handler)
        
        # Set higher level for third-party libraries
        logging.getLogger('urllib3').setLevel(logging.WARNING)
        logging.getLogger('PIL').setLevel(logging.WARNING)
        
    def handle_error(self, error, error_type=None, context=None, show_notification=True):
        # Determine error type if not provided
        if error_type is None:
            error_type = self._categorize_error(error)
            
        # Log the error with context
        error_message = str(error)
        context_str = f" (Context: {context})" if context else ""
        logging.error(f"{error_type} error: {error_message}{context_str}")
        
        # Get user-friendly message
        user_message = self._get_user_message(error_type, error)
        
        # Show notification if requested
        if show_notification:
            # Implementation depends on notification system
            pass
            
        return {
            'type': error_type,
            'message': user_message,
            'original_error': error_message,
            'context': context
        }
        
    def _categorize_error(self, error):
        error_str = str(error).lower()
        
        if isinstance(error, requests.exceptions.RequestException):
            return 'network'
            
        if 'api key' in error_str or 'authentication' in error_str:
            return 'api'
            
        if 'permission' in error_str or 'access' in error_str:
            return 'permission'
            
        if 'microphone' in error_str or 'audio' in error_str:
            return 'audio'
            
        return 'general'
        
    def _get_user_message(self, error_type, error):
        error_str = str(error).lower()
        
        messages = {
            'network': "Network connection issue. Please check your internet connection.",
            'api': "API authentication error. Please check your API keys in settings.",
            'permission': "Permission denied. The application needs additional permissions.",
            'audio': "Audio device error. Please check your microphone settings.",
            'general': "An error occurred. Please check the logs for details."
        }
        
        # Special case handling
        if 'rate limit' in error_str:
            return "API rate limit exceeded. Please try again in a moment."
            
        if 'no microphone' in error_str:
            return "No microphone detected. Please connect a microphone and try again."
            
        return messages.get(error_type, messages['general'])
        
    def get_log_file_path(self):
        # Return path to current log file for troubleshooting
        log_dir = os.path.join(
            os.environ.get('APPDATA'),
            'VoiceDictationAssistant',
            'logs'
        )
        return os.path.join(log_dir, 'app.log')
```

Implement automatic error reporting (opt-in) for improving the application. Add log rotation to prevent excessive disk usage.

# Test Strategy:
1. Test error categorization with various error types
2. Verify logging system creates appropriate log files
3. Test user-friendly message generation
4. Verify error recovery strategies work as expected
5. Test log rotation with simulated large logs
6. Verify contextual information is properly included in logs
7. Test performance impact of logging during normal operation
