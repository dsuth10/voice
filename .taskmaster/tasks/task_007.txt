# Task ID: 7
# Title: Create Configuration Management System
# Status: pending
# Dependencies: 1
# Priority: high
# Description: Implement a configuration system that manages user preferences, API keys, and application settings with secure storage.
# Details:
Develop a ConfigManager class that:

1. Stores and retrieves user preferences
   - Hotkey settings
   - API keys (encrypted)
   - Audio settings
   - AI enhancement preferences

2. Implements secure storage for sensitive information
   - Use Windows Data Protection API (DPAPI) via pywin32 for encrypting API keys
   - Store configuration in user's AppData folder

3. Supports multiple configuration profiles

Implementation approach:
```python
class ConfigManager:
    def __init__(self, config_file=None):
        self.config_file = config_file or os.path.join(
            os.environ.get('APPDATA'), 
            'VoiceDictationAssistant', 
            'config.yaml'
        )
        self.config = self._load_config()
        
    def _load_config(self):
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    return yaml.safe_load(f) or {}
            except Exception as e:
                logging.error(f"Failed to load config: {e}")
                return self._create_default_config()
        else:
            return self._create_default_config()
    
    def _create_default_config(self):
        config = {
            'hotkey': 'ctrl+win+space',
            'push_to_talk': True,
            'api_keys': {
                'assemblyai': '',
                'openai': ''
            },
            'audio': {
                'sample_rate': 16000,
                'channels': 1,
                'chunk_size': 1024
            },
            'ai': {
                'model': 'gpt-4o-mini',
                'remove_fillers': True,
                'improve_grammar': True
            }
        }
        self._save_config(config)
        return config
    
    def _save_config(self, config=None):
        if config is not None:
            self.config = config
            
        os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
        with open(self.config_file, 'w') as f:
            yaml.dump(self.config, f)
    
    def get(self, key, default=None):
        # Support nested keys like 'audio.sample_rate'
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        return value
    
    def set(self, key, value):
        keys = key.split('.')
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value
        self._save_config()
        
    def encrypt_api_key(self, service, key):
        # Use DPAPI to encrypt the API key
        if key:
            encrypted_data = win32crypt.CryptProtectData(
                key.encode(), 
                description="VoiceDictationAssistant", 
                entropy=None, 
                reserved=0, 
                prompt_struct=None
            )
            self.set(f'api_keys.{service}', base64.b64encode(encrypted_data).decode())
            
    def decrypt_api_key(self, service):
        encrypted_key = self.get(f'api_keys.{service}')
        if not encrypted_key:
            return ''
            
        try:
            encrypted_data = base64.b64decode(encrypted_key)
            decrypted_data, _ = win32crypt.CryptUnprotectData(
                encrypted_data,
                entropy=None,
                reserved=0,
                prompt_struct=None
            )
            return decrypted_data.decode()
        except Exception as e:
            logging.error(f"Failed to decrypt API key: {e}")
            return ''
```

Implement a configuration wizard for first-time setup. Add validation for configuration values to prevent errors.

# Test Strategy:
1. Test loading and saving configuration files
2. Verify encryption and decryption of API keys
3. Test default configuration creation
4. Verify nested configuration access
5. Test configuration persistence across application restarts
6. Verify configuration file permissions are secure
7. Test configuration validation
8. Verify multiple profile support
